<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net" #>
<#@ assembly name="System.Core" #>
<#+
    private static IList<(string Extension, string Type)> GetMediaTypeList()
    {
        using var client = new WebClient();

        var list = client.DownloadString(new Uri("http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"));
        var lines = SplitString(list, '\r', '\n');

        return GetMediaTypes(lines).ToList();
    }

    private static IEnumerable<(string Extension, string Type)> GetMediaTypes(IEnumerable<string> lines)
        => lines.Where(x => !x.StartsWith("#"))
            .Select(line => SplitString(line, '\t', ' '))
            .SelectMany(CreateMediaTypes)
            .GroupBy(x => x.Extension)
            .Where(x => x.Count() == 1)
            .Select(x => x.Single())
            .OrderBy(x => x.Extension);

    private static string[] SplitString(string line, params char[] separator)
        => line.Split(separator, StringSplitOptions.RemoveEmptyEntries);

    private static IEnumerable<(string Extension, string Type)> CreateMediaTypes(string[] parts)
        => parts.Skip(1).Select(extension => (extension, parts[0]));

    public void GenerateClass(bool includeAttributes)
    {
#>
// <auto-generated />

#nullable enable
#pragma warning disable

namespace $rootnamespace$
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Runtime.CompilerServices;

    /// <summary>
    /// Provides utilities for mapping file names and extensions to MIME-types.
    /// </summary>
    [CompilerGenerated]
    [DebuggerNonUserCode]
    public static class MimeTypes
    {
        private const string DefaultFallbackMimeType = "application/octet-stream";
        private static string s_fallbackMimeType;

        /// <summary>
        /// The fallback MIME-type. Defaults to <c>application/octet-stream</c>.
        /// </summary>
        [AllowNull]
        public static string FallbackMimeType
        {
            get => s_fallbackMimeType;
            set => s_fallbackMimeType = value ?? DefaultFallbackMimeType;
        }

        private static readonly Dictionary<string, string> s_typeMap;

        static MimeTypes()
        {
            s_fallbackMimeType = DefaultFallbackMimeType;

            s_typeMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            {
        <#+ foreach (var mediaType in GetMediaTypeList()) { #>
        { "<#= mediaType.Item1 #>", "<#= mediaType.Item2 #>" },
        <#+ } #>
    };
        }

        /// <summary>
        /// Tries to get the MIME-type for the given file name.
        /// </summary>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="mimeType">The MIME-type for the given file name.</param>
        /// <returns><c>true</c> if a MIME-type was found, <c>false</c> otherwise.</returns>
        public static bool TryGetMimeType(string? fileName, [NotNullWhen(true)] out string? mimeType)
        {
            if (fileName is null)
            {
                mimeType = null;
                return false;
            }

            var dotIndex = fileName.LastIndexOf('.');

            if (dotIndex != -1 && fileName.Length > dotIndex + 1)
            {
                return s_typeMap.TryGetValue(fileName.Substring(dotIndex + 1), out mimeType);
            }

            mimeType = null;
            return false;
        }

        /// <summary>
        /// Gets the MIME-type for the given file name,
        /// or <see cref="FallbackMimeType"/> if a mapping doesn't exist.
        /// </summary>
        /// <param name="fileName">The name of the file.</param>
        /// <returns>The MIME-type for the given file name.</returns>
        public static string GetMimeType(string? fileName)
        {
            if (fileName is null) throw new ArgumentNullException(nameof(fileName));

            return TryGetMimeType(fileName, out var result) ? result : FallbackMimeType;
        }
    }
}
<#+ if (includeAttributes) { #>

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]
    internal sealed class AllowNullAttribute : Attribute { }

    /// <summary>Specifies that when a method returns <see cref="ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
    [AttributeUsage(AttributeTargets.Parameter)]
    internal sealed class NotNullWhenAttribute : Attribute
    {
        /// <summary>Initializes the attribute with the specified return value condition.</summary>
        /// <param name="returnValue">
        /// The return value condition. If the method returns this value, the associated parameter will not be null.
        /// </param>
        public NotNullWhenAttribute(bool returnValue) => ReturnValue = returnValue;

        /// <summary>Gets the return value condition.</summary>
        public bool ReturnValue { get; }
    }
}
<#+ } #>

#pragma warning enable
<#+
    }
#>